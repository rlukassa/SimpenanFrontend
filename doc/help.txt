Nah sekarang anda tahu terkait tugas saya kurang lebih
Sebenarnya ini merupakan satu bagian dari backend dari tugas saya yaitu membuat web development mirip seperti Little Alchemy namun mengimplementasikan BFS, DFS dan bidirectional (meskipun item yang diambil adalah scrapping dari Little Alchemy 2 )
Saya sudah melakukan webscrapping dari Little Alchemy 2, dan terdapat mapper.json dan alchemy.db. Dimana mapper.json terdiri dari nama element dan gambar, sebagai key value -> agar harapannya dapat menampilkan gambar dan nama (dengan key) dibawahnya
dan juga alchemy.db yang merupakan database dari element dan 2 pembentuknya  (misalkan water, heat, snow | water, heat, ice) Perhatikan bahwa water bisa terbentuk dari 2 elemen. 

Anda sebelumnya sudah membuat logikanya dengan bantuan Express.js, namun sekarang saya ingin membuatnya dalam bahasa golang untuk backend dan react.jsx untuk frontend 
Namun, kebetulan react.jsx nya sudah dibuat designnya (meskipun terdapat item dummy yang harus diganti dengan database tadi dan dan ada masih bersifat manual javascript)
Nah aku ingin, anda sebagai webdeveloper yang andal untuk melanjutkan project kami, terutama dalam backend : 
1. Mengubah dari yang item dummy agar ditunjukkan dari backend dan database saja, sehingga frontend memanggil fungsi untuk menampilkan saja
2. Mengimplementasi BFS, DFS, dan Bidirectional pada elemen yang dipilih untuk menghasilkan tree secara live update dengan delay (seperti yang telah dicoba sebelumnya dengan d3), namun menampilkan gambar dan nama elemen yang diambil dari mapper.json
3. Mengimplementasi juga apa yang ada di Design Frontend yang dihitung dalam backend

Namun perhatikan bahwa, jangan merusak / mengubah sama sekali design yang sudah dibuat oleh Frontend, itu bersifat final. Anda tetap bisa melakukan refactor, yaitu memindahkan suatu hal dummy dari frontend ke backend yang sudah lengkap databasenya

Perhatikan juga pada frontendnya agar disesuaikan dengan backendnya 
-- progress update simulasinya agar disesuaikan dengan progress benar dari backend 
-- adapun juga nodes visited dan execution time yang disessuaikan dengan backendnya (progress)
-- targetElement, Algorithm,  dan Recipe Type pada Frontend yang disesuikan denga apa yang dipilih 

dan lain lainnya coba sesuaikan. 

dengan struktur direktori berikut
 Untuk folder Frontend

C:.
│   Dockerfile
│   
├───public
│   │   App.css
│   │   index.css
│   │   vite.svg
│   │   
│   └───icons
└───src
    │   main.jsx
    │   
    ├───assets
    │       react.svg
    │       test-tube.png
    │
    ├───components
    │       ControlsPanel.jsx Komponen untuk toggle dan input 
    │       ElementPicker.jsx Komponen untuk memilih elemen
    │       RecipeResults.jsx Komponen untuk menghasilkan banyak node dan waktu 
    │       SearchBar.jsx Komponen untuk mencari elemen
    │       TreeVisualizer.jsx Komponen untuk visualisasi tree dengan d3
    │
    ├───hooks
    │       useSearch.js hook untuk fetching data dari backend
    │
    ├───pages
    │       App.jsx
    │
    └───utils
            helpers.js // format data (apabila diperlukan tambahan, lebih dari database)

backend 

C:.
│   Dockerfile
│   go.mod
│   main.go entry point 
│
├───config
│       config.go Konfigurasi global (kalo diperlukan)
│
├───controllers
│       recipeController.go Logic untuk pencarian dengan BFS, DFS, Bidirectional
│
├───middleware
│       errorHandler.go Errorhandler program 
│
├───router
│       router.go Setup semua endpoint API
│
├───services
│       search.go Algoritma pencarian (BFS, DFS, Bidirectional)
│
└───utils
        response.go standard response dan error handler 

database 
    alchemy.db --> database element dan 2 pembentuknya 
    buat-mapper.js --> ignore
    mapper.json --> berisi nama element, dan fotonya

berikut ini front end yang sudah dibuat (dengan beberapa perlu penyesuaian) 

"use client"

import { useState } from "react"

// ====================================== CATATAN =======================================
// ini buat page 2 yang ada di sebelah kanan, ini adalah panel kontrol yang berfungsi untuk mengatur algoritma pencarian dan jenis resep yang akan ditampilkan.

export default function ControlsPanel({ searchParams, setSearchParams }) {
  const [maxRecipes, setMaxRecipes] = useState(5)   // ini default value, bisa diubah sesuai kebutuhan, nilai ini akan digunakan untuk mengatur jumlah maksimum resep yang ditampilkan ketika recipeType adalah "Limit"

  const handleAlgorithmChange = (algorithm) => {
    setSearchParams((prev) => ({ ...prev, algorithm }))
  } // fungsi ini digunakan untuk mengubah algoritma pencarian yang digunakan dalam aplikasi. Ketika pengguna memilih algoritma baru, fungsi ini akan memperbarui parameter pencarian dengan algoritma yang dipilih.

  const handleRecipeTypeChange = (recipeType) => {
    setSearchParams((prev) => ({ ...prev, recipeType }))
  } // fungsi ini digunakan untuk mengubah jenis resep yang akan dicari. Ketika pengguna memilih jenis resep baru, fungsi ini akan memperbarui parameter pencarian dengan jenis resep yang dipilih.

  const handleMaxRecipesChange = (e) => {
    const value = Number.parseInt(e.target.value)
    setMaxRecipes(value)
    setSearchParams((prev) => ({ ...prev, maxRecipes: value }))
  } // fungsi ini digunakan untuk mengubah jumlah maksimum resep yang akan ditampilkan ketika jenis resep yang dipilih adalah "Limit". Ketika pengguna mengubah nilai input, fungsi ini akan memperbarui nilai maksimum resep dan juga memperbarui parameter pencarian.

  return (
    <div className="controls-panel"> 
      <div className="algorithm-options"> 
        <h3>Algorithm Options</h3>
{/* Pilihan algoritma yang dipilih  */}
        <div className="option">
          <input
            type="radio"
            id="bfs"
            name="algorithm"
            checked={searchParams.algorithm === "BFS"}
            onChange={() => handleAlgorithmChange("BFS")}
          />
          <label htmlFor="bfs">
            <strong>BFS</strong>
            <div className="option-description">Breadth First Search</div>
          </label>
        </div>

        <div className="option">
          <input
            type="radio"
            id="dfs"
            name="algorithm"
            checked={searchParams.algorithm === "DFS"}
            onChange={() => handleAlgorithmChange("DFS")}
          />
          <label htmlFor="dfs">
            <strong>DFS</strong>
            <div className="option-description">Depth First Search</div>
          </label>
        </div>

        <div className="option">
          <input
            type="radio"
            id="bidirectional"
            name="algorithm"
            checked={searchParams.algorithm === "Bidirectional"}
            onChange={() => handleAlgorithmChange("Bidirectional")}
          />
          <label htmlFor="bidirectional">
            <strong>Bidirectional</strong>
            <div className="option-description">Search from both ends</div>
          </label>
        </div>
      </div>

      <div className="recipe-options">
        <h3>Recipe Options</h3>

        <div className="option">
          <input
            type="radio"
            id="best-recipe"
            name="recipeType"
            checked={searchParams.recipeType === "Best"}
            onChange={() => handleRecipeTypeChange("Best")}
          />
          <label htmlFor="best-recipe">
            <strong>Best Recipe</strong>
            <div className="option-description">Find the shortest path Recipe for the element</div>
          </label>
        </div>

        <div className="option">
          <input
            type="radio"
            id="all-recipes"
            name="recipeType"
            checked={searchParams.recipeType === "All"}
            onChange={() => handleRecipeTypeChange("All")}
          />
          <label htmlFor="all-recipes">
            <strong>All Recipes</strong>
            <div className="option-description">Find all possible Recipes for the element</div>
          </label>
        </div>

        <div className="option">
          <input
            type="radio"
            id="limit-recipes"
            name="recipeType"
            checked={searchParams.recipeType === "Limit"}
            onChange={() => handleRecipeTypeChange("Limit")}
          />
          <label htmlFor="limit-recipes">
            <strong>Limit Recipes</strong>
            <div className="option-description">Limit to a Specified number of unique/different Recipes</div>
          </label>
        </div>

        {searchParams.recipeType === "Limit" && (
          <div className="max-recipes">
            <label htmlFor="max-recipes">Maximum Recipes</label>
            <input
              type="number"
              id="max-recipes"
              min="1"
              max="30"
              value={maxRecipes}
              onChange={handleMaxRecipesChange}
            />
          </div>
        )}
      </div>
    </div>
  )
}

"use client"

import { useState, useEffect } from "react"
import { fetchElements } from "../utils/helpers.js"

// ======================================= CATATAN =======================================
// ini adalah komponen yang digunakan untuk memilih elemen-elemen yang akan digunakan dalam pencarian resep. Komponen ini menampilkan daftar elemen dalam bentuk grid dan memungkinkan pengguna untuk memilih elemen dengan mengkliknya. Selain itu, komponen ini juga menyediakan fitur pagination untuk menavigasi antara halaman-halaman elemen yang

export default function ElementPicker({ onElementSelect, selectedElement }) {
  const [elements, setElements] = useState([]) // ini adalah state yang digunakan untuk menyimpan daftar elemen yang diambil dari server. State ini diinisialisasi dengan array kosong dan akan diisi dengan data elemen setelah diambil dari server.
  const [currentPage, setCurrentPage] = useState(1) // ini adalah state yang digunakan untuk menyimpan halaman saat ini yang sedang ditampilkan. State ini diinisialisasi dengan nilai 1, yang berarti halaman pertama.
  const [totalPages, setTotalPages] = useState(1) // ini adalah state yang digunakan untuk menyimpan total jumlah halaman yang tersedia berdasarkan jumlah elemen yang diambil dari server. State ini diinisialisasi dengan nilai 1, yang berarti hanya ada satu halaman.
  const elementsPerPage = 8 // ini adalah konstanta yang digunakan untuk menentukan jumlah elemen yang ditampilkan pada setiap halaman. Nilai ini diatur menjadi 8, yang berarti 8 elemen akan ditampilkan pada setiap halaman.

  useEffect(() => {
    const loadElements = async () => {
      const allElements = await fetchElements()
      setElements(allElements) // ini adalah fungsi yang digunakan untuk mengambil data elemen dari server menggunakan fungsi fetchElements. Setelah data diambil, state elements akan diperbarui dengan data elemen yang diterima.
      setTotalPages(Math.ceil(allElements.length / elementsPerPage)) 
    } // ini adalah fungsi yang digunakan untuk menghitung total jumlah halaman berdasarkan jumlah elemen yang diambil dari server. Fungsi ini membagi jumlah total elemen dengan jumlah elemen per halaman (elementsPerPage) dan membulatkan hasilnya ke atas menggunakan Math.ceil untuk mendapatkan jumlah halaman yang diperlukan.

    loadElements()
  }, [])

  const getElementsForCurrentPage = () => {
    const startIndex = (currentPage - 1) * elementsPerPage  // ini adalah fungsi yang digunakan untuk mendapatkan elemen-elemen yang akan ditampilkan pada halaman saat ini. Fungsi ini menghitung indeks awal berdasarkan halaman saat ini dan jumlah elemen per halaman, kemudian mengembalikan elemen-elemen yang sesuai
    return elements.slice(startIndex, startIndex + elementsPerPage)
  }

  const handlePageChange = (page) => {
    setCurrentPage(page)
  }

  const getElementIcon = (element) => { // ini adalah fungsi yang digunakan untuk mendapatkan ikon yang sesuai dengan nama elemen. Fungsi ini menggunakan switch case untuk memeriksa nama elemen dan mengembalikan ikon yang sesuai.
    switch (element.name.toLowerCase()) { // diatur di backend, ini adalah nama elemen yang diambil dari server
      case "water":
        return "💧"
      case "fire":
        return "🔥"
      case "earth":
        return "🌋"
      case "air":
        return "💨"
      case "heat":
        return "♨️"
      case "ice":
        return "🧊"
      case "snow":
        return "❄️"
      case "coal":
        return "🪨"
      default:
        return "🧪"
    }
  }

  return (
    <div className="element-picker">
      <div className="elements-grid">
        {getElementsForCurrentPage().map((element) => (
          <div
            key={element.id}
            className={`element-item ${selectedElement?.id === element.id ? "selected" : ""}`}
            onClick={() => onElementSelect(element)}
          >
            <div className="element-icon">{getElementIcon(element)}</div>
            <div className="element-name">{element.name}</div>
          </div>
        ))}
      </div>

        {/* atur paginationnya supaya dapat teratur dari banyak database */}
      <div className="pagination">
        <button
          className="pagination-button"
          onClick={() => handlePageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          &lt;
        </button>

        {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
          const pageNumber =
            currentPage <= 3 ? i + 1 : currentPage >= totalPages - 2 ? totalPages - 4 + i : currentPage - 2 + i

          if (pageNumber <= totalPages) {
            return (
              <button
                key={pageNumber}
                className={`pagination-button ${currentPage === pageNumber ? "active" : ""}`}
                onClick={() => handlePageChange(pageNumber)}
              >
                {pageNumber}
              </button>
            )
          }
          return null
        })}

        <button
          className="pagination-button"
          onClick={() => handlePageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          &gt;
        </button>
      </div>
    </div>
  )
}

export default function RecipeResults({
    selectedElement,
    algorithm,
    recipeType,
    progress,
    executionTime,
    nodesVisited,
  }) {
    return (
      <div className="recipe-details">
        <h2>Recipe Details</h2>
  
        <div className="detail-section">
          <h3>Target Element</h3>
          <div className="detail-value">{selectedElement?.name || "None"}</div>
        </div>
  
        <div className="detail-section">
          <h3>Algorithm</h3>
          <div className="detail-value">{algorithm}</div>
        </div>
  
        <div className="detail-section">
          <h3>Recipe Type</h3>
          <div className="detail-value">{recipeType === "Best" ? "Shortest Path" : recipeType}</div>
        </div>

        // atur progress bar supaya lebih menarik dan sessuai progress yang ada
        <div className="detail-section">
          <h3>Progress</h3>
          <div className="progress-bar">
            <div className="progress-fill" style={{ width: `${progress}%` }}></div>
          </div>
        </div>
      
      // atur agar executionya sesuai  backend dan proses
        <div className="metrics">
          <div className="metric">
            <div className="metric-icon">⏱️</div>
            <div className="metric-details">
              <h3>Execution Time</h3>
              <div className="metric-value">{executionTime}ms</div>
            </div>
          </div>  

        // atur agar nodes visited sesuai dengan backend dan proses
          <div className="metric">
            <div className="metric-icon">🔍</div>
            <div className="metric-details">
              <h3>Nodes Visited</h3>
              <div className="metric-value">{nodesVisited}</div>
            </div>
          </div>
        </div>
      </div>
    )
  }
  
"use client"

import { useState, useEffect, useRef } from "react"
import { fetchElements } from "../utils/helpers"
import { useSearch } from "../hooks/useSearch"

// ======================================= CATATAN =======================================
// // ini adalah komponen yang digunakan untuk menampilkan bilah pencarian dan daftar elemen yang dapat dipilih. Komponen ini memungkinkan pengguna untuk mencari elemen berdasarkan nama dan memilih elemen dari daftar hasil pencarian. Selain itu, komponen ini juga menangani interaksi dengan pengguna seperti mengklik di luar dropdown untuk menutupnya dan menghapus teks pencarian.
// ATUR AGAR BISA SESUAI DENGAN DATABASE
export default function SearchBar({ onElementSelect }) {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)
  const dropdownRef = useRef(null)
  
  // search state
  const { 
    searchTerm, 
    setSearchTerm, 
    items: elements, 
    setItems: setElements, 
    filteredItems: filteredElements 
  } = useSearch([])

  useEffect(() => { // ambil data elemen dari server
    const loadElements = async () => {
      try {
        const allElements = await fetchElements()
        console.log("Loaded elements:", allElements)
        setElements(allElements)
      } catch (error) {
        console.error("Error loading elements:", error)
      }
    }

    loadElements()
  }, [setElements])

  // dropdown visibility based on search
  useEffect(() => {
    setIsDropdownOpen(searchTerm.trim() !== "")
  }, [searchTerm])

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [])

  const handleSearchChange = (e) => {
    const value = e.target.value
    console.log("Search input changed to:", value)
    setSearchTerm(value)
  }

  const handleElementSelect = (element) => {
    console.log("Element selected:", element)
    onElementSelect(element)
    setSearchTerm(element.name)
    setIsDropdownOpen(false)
  }

  return (
    <div className="search-bar-container" ref={dropdownRef}>
      <div className="search-input-wrapper">
        <input
          type="text"
          className="search-input"
          placeholder="Search elements..."
          value={searchTerm}
          onChange={handleSearchChange}
          onFocus={() => {
            console.log("Input focused, current search term:", searchTerm)
            setIsDropdownOpen(searchTerm.trim() !== "")
          }}
        />
        {searchTerm && (
          <button 
            className="clear-button" 
            onClick={() => {
              console.log("Clear button clicked")
              setSearchTerm("")
            }}
          >
            ×
          </button>
        )}
      </div>

      {isDropdownOpen && (
        <div className="search-dropdown">
          {filteredElements.length > 0 ? (
            filteredElements.map((element) => (
              <div 
                key={element.id} 
                className="dropdown-item" 
                onClick={() => handleElementSelect(element)}
              >
                {element.name}
                {element.description && (
                  <span className="element-description">{element.description}</span>
                )}
              </div>
            ))
          ) : (
            <div className="search-dropdown no-results">
              No elements found matching "{searchTerm}"
            </div>
          )}
        </div>
      )}
    </div>
  )
}


"use client"

import { useEffect, useRef, useState } from "react"
import * as d3 from "d3"

// ======================================= CATATAN =======================================
// ini adalah komponen yang digunakan untuk menampilkan visualisasi pohon dari hasil pencarian resep. Komponen ini menggunakan D3.js untuk menggambar pohon dan memungkinkan pengguna untuk memperbesar atau memperkecil tampilan pohon. Selain itu, komponen ini juga menangani pemuatan data dan menampilkan pesan ketika tidak ada resep yang ditemukan atau saat sedang memuat data.
// HASILKAN TREE YANG BERDASARKAN D3 kemarin, namun dengan efffect yang menarik dan sesuai dengan hasil pencarian yang ada di backend
// tentunya dengan live update dan delay 
export default function TreeVisualizer({ results, selectedElement, isLoading }) {
  const svgRef = useRef(null)
  const containerRef = useRef(null)
  const [zoom, setZoom] = useState(1)

  useEffect(() => {
    if (!results || results.length === 0 || isLoading) return

    renderTree()
  }, [results, isLoading, zoom])

  const handleZoomIn = () => {
    setZoom((prev) => Math.min(prev + 0.1, 2))
  }

  const handleZoomOut = () => {
    setZoom((prev) => Math.max(prev - 0.1, 0.5))
  }

  const handleResetZoom = () => {
    setZoom(1)
  }

  const renderTree = () => {
    if (!svgRef.current || !containerRef.current) return

    // Clear previous visualization
    d3.select(svgRef.current).selectAll("*").remove()

    const width = containerRef.current.clientWidth
    const height = containerRef.current.clientHeight

    // (DUMMY DATA STRUCTURE)
    const treeData = {
      name: selectedElement?.name || "Element",
      children: [
        {
          name: "Mud",
          children: [
            { name: "Water", children: [] },
            { name: "Earth", children: [] },
          ],
        },
        {
          name: "Stone",
          children: [
            {
              name: "Clay",
              children: [
                { name: "Mud", children: [] },
                { name: "Sand", children: [] },
              ],
            },
          ],
        },
      ],
    }

    // Tree layout
    const treeLayout = d3.tree().size([height - 100, width - 160])

    // Hierarchy for tree
    const root = d3.hierarchy(treeData)

    // Assign x and y coordinates to each node
    treeLayout(root)

    const svg = d3
      .select(svgRef.current)
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", `translate(80, 50) scale(${zoom})`)

    // Create links
    svg
      .selectAll(".link")
      .data(root.links())
      .enter()
      .append("path")
      .attr("class", "link")
      .attr(
        "d",
        d3
          .linkHorizontal()
          .x((d) => d.y)
          .y((d) => d.x),
      )
      .attr("fill", "none")
      .attr("stroke", "#6366f1")
      .attr("stroke-width", 2)

    // Create nodes
    const nodes = svg
      .selectAll(".node")
      .data(root.descendants())
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", (d) => `translate(${d.y}, ${d.x})`)

    nodes
      .append("rect")
      .attr("x", -50)
      .attr("y", -15)
      .attr("width", 100)
      .attr("height", 30)
      .attr("rx", 5)
      .attr("ry", 5)
      .attr("fill", (d) => (d.depth === 0 ? "#4f46e5" : "#3b82f6"))
      .attr("stroke", "#1e3a8a")
      .attr("stroke-width", 1)

    // Add node text
    nodes
      .append("text")
      .attr("dy", "0.35em")
      .attr("text-anchor", "middle")
      .attr("fill", "white")
      .text((d) => d.data.name)
  }

  if (isLoading) {
    return (
      <div className="tree-loading">
        <div className="spinner"></div>
        <p>Searching for recipes...</p>
      </div>
    )
  }

  if (!results || results.length === 0) {
    return (
      <div className="tree-empty">
        <p>No recipe found for the selected element.</p>
      </div>
    )
  }

  return (
    <div className="tree-container" ref={containerRef}>
      <svg ref={svgRef}></svg>

      <div className="zoom-controls">
        <button className="zoom-button" onClick={handleZoomIn}>
          +
        </button>
        <button className="zoom-button" onClick={handleResetZoom}>
          ⟳
        </button>
        <button className="zoom-button" onClick={handleZoomOut}>
          -
        </button>
      </div>
    </div>
  )
}


bagian utama App.jsx


"use client"

import { useState } from "react"
import ElementPicker from "../components/ElementPicker"
import ControlsPanel from "../components/ControlsPanel"
import SearchBar from "../components/SearchBar"
import RecipeResults from "../components/RecipeResults"
import TreeVisualizer from "../components/TreeVisualizer"
import { useSearch } from "../hooks/useSearch"
import testTubeIcon from "../assets/test-tube.png"
import "../../public/App.css"

export default function App() {
  const [currentView, setCurrentView] = useState("landing") // 'landing', 'search', 'results'
  const [selectedElement, setSelectedElement] = useState(null)
  const {
    searchParams,
    setSearchParams,
    searchResults,
    isLoading,
    executionTime,
    nodesVisited,
    progress,
    startSearch,
    resetSearch,
  } = useSearch()

  const handleStartExploring = () => {
    setCurrentView("search")
  }

  const handleStartSearch = () => {
    if (!selectedElement) return
    startSearch(selectedElement)
    setCurrentView("results")
  }

  const handleBackToSearch = () => {
    resetSearch()
    setCurrentView("search")
  }

  const renderLandingPage = () => (
    <div className="landing-container">
      <div className="landing-content">
        <h1 className="discover-text">Discover the Secrets of</h1>
        <div className="title-container">
          <h1 className="title">Little Alchemy 2</h1>
          <img src={testTubeIcon || "/placeholder.svg"} alt="Test tube" className="test-tube-icon" />
        </div>
        <h2 className="subtitle">Recipe Finder</h2>

        <div className="basic-elements">
          <div className="element-card">
            <div className="element-icon water-icon">💧</div>
            <h3>Water</h3>
            <p className="element-description">The fluid of life</p>
          </div>
          <div className="element-card">
            <div className="element-icon fire-icon">🔥</div>
            <h3>Fire</h3>
            <p className="element-description">The energy of transformation</p>
          </div>
          <div className="element-card">
            <div className="element-icon earth-icon">🌋</div>
            <h3>Earth</h3>
            <p className="element-description">The foundation of creation</p>
          </div>
          <div className="element-card">
            <div className="element-icon air-icon">💨</div>
            <h3>Air</h3>
            <p className="element-description">The breath of existence</p>
          </div>
        </div>

        <p className="description">
          Uncover the secrets of Little Alchemy 2 with our advanced recipe finder.
          <br />
          Explore paths from basics to complex creations using BFS, DFS, and Bidirectional search.
        </p>

        <button className="start-button" onClick={handleStartExploring}>
          <img src={testTubeIcon || "/placeholder.svg"} alt="" className="button-icon" /> Start Exploring
        </button>
      </div>
    </div>
  )

  const renderSearchPage = () => (
    <div className="search-container">
      <h1 className="search-title">Search Elements</h1>
      <p className="search-subtitle">Select an element below to find its recipes</p>

      <div className="search-content">
        <SearchBar onElementSelect={setSelectedElement} />

        <div className="search-grid">
          <ElementPicker onElementSelect={setSelectedElement} selectedElement={selectedElement} />

          <div className="controls-container">
            <ControlsPanel searchParams={searchParams} setSearchParams={setSearchParams} />

            <button className="search-button" onClick={handleStartSearch} disabled={!selectedElement}>
              <span className="search-icon">🔍</span> Start Search
            </button>
          </div>
        </div>
      </div>
    </div>
  )

  const renderResultsPage = () => (
    <div className="results-container">
      <div className="results-header">
        <button className="back-button" onClick={handleBackToSearch}>
          ← Back to Search
        </button>
        <button className="print-button">
          <span className="print-icon">🖨️</span> Print Tree
        </button>
      </div>

      <div className="results-content">
        <RecipeResults
          selectedElement={selectedElement}
          algorithm={searchParams.algorithm}
          recipeType={searchParams.recipeType}
          progress={progress}
          executionTime={executionTime}
          nodesVisited={nodesVisited}
        />



        <div className="visualization-container">

 
  
   0.3.20 .
   03
         <h2 className="visualization-title">Recipe Visualization</h2>
          <TreeVisualizer results={searchResults} selectedElement={selectedElement} isLoading={isLoading} />
        </div>
      </div>
    </div>
  )

  return (
    <div className="app">
      {currentView === "landing" && renderLandingPage()}
      {currentView === "search" && renderSearchPage()}
      {currentView === "results" && renderResultsPage()}
    </div>
  )
}



"use client"

import { useEffect, useRef, useState } from "react"
import * as d3 from "d3"

// ======================================= CATATAN =======================================
// ini adalah komponen yang digunakan untuk menampilkan visualisasi pohon dari hasil pencarian resep. Komponen ini menggunakan D3.js untuk menggambar pohon dan memungkinkan pengguna untuk memperbesar atau memperkecil tampilan pohon. Selain itu, komponen ini juga menangani pemuatan data dan menampilkan pesan ketika tidak ada resep yang ditemukan atau saat sedang memuat data.
// HASILKAN TREE YANG BERDASARKAN D3 kemarin, namun dengan efffect yang menarik dan sesuai dengan hasil pencarian yang ada di backend
// tentunya dengan live update dan delay 
export default function TreeVisualizer({ results, selectedElement, isLoading }) {
  const svgRef = useRef(null)
  const containerRef = useRef(null)
  const [zoom, setZoom] = useState(1)

  useEffect(() => {
    if (!results || results.length === 0 || isLoading) return

    renderTree()
  }, [results, isLoading, zoom])

  const handleZoomIn = () => {
    setZoom((prev) => Math.min(prev + 0.1, 2))
  }

  const handleZoomOut = () => {
    setZoom((prev) => Math.max(prev - 0.1, 0.5))
  }

  const handleResetZoom = () => {
    setZoom(1)
  }

  const renderTree = () => {
    if (!svgRef.current || !containerRef.current) return

    // Clear previous visualization
    d3.select(svgRef.current).selectAll("*").remove()

    const width = containerRef.current.clientWidth
    const height = containerRef.current.clientHeight

    // (DUMMY DATA STRUCTURE)
    const treeData = {
      name: selectedElement?.name || "Element",
      children: [
        {
          name: "Mud",
          children: [
            { name: "Water", children: [] },
            { name: "Earth", children: [] },
          ],
        },
        {
          name: "Stone",
          children: [
            {
              name: "Clay",
              children: [
                { name: "Mud", children: [] },
                { name: "Sand", children: [] },
              ],
            },
          ],
        },
      ],
    }

    // Tree layout
    const treeLayout = d3.tree().size([height - 100, width - 160])

    // Hierarchy for tree
    const root = d3.hierarchy(treeData)

    // Assign x and y coordinates to each node
    treeLayout(root)

    const svg = d3
      .select(svgRef.current)
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", `translate(80, 50) scale(${zoom})`)

    // Create links
    svg
      .selectAll(".link")
      .data(root.links())
      .enter()
      .append("path")
      .attr("class", "link")
      .attr(
        "d",
        d3
          .linkHorizontal()
          .x((d) => d.y)
          .y((d) => d.x),
      )
      .attr("fill", "none")
      .attr("stroke", "#6366f1")
      .attr("stroke-width", 2)

    // Create nodes
    const nodes = svg
      .selectAll(".node")
      .data(root.descendants())
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", (d) => `translate(${d.y}, ${d.x})`)

    nodes
      .append("rect")
      .attr("x", -50)
      .attr("y", -15)
      .attr("width", 100)
      .attr("height", 30)
      .attr("rx", 5)
      .attr("ry", 5)
      .attr("fill", (d) => (d.depth === 0 ? "#4f46e5" : "#3b82f6"))
      .attr("stroke", "#1e3a8a")
      .attr("stroke-width", 1)

    // Add node text
    nodes
      .append("text")
      .attr("dy", "0.35em")
      .attr("text-anchor", "middle")
      .attr("fill", "white")
      .text((d) => d.data.name)
  }

  if (isLoading) {
    return (
      <div className="tree-loading">
        <div className="spinner"></div>
        <p>Searching for recipes...</p>
      </div>
    )
  }

  if (!results || results.length === 0) {
    return (
      <div className="tree-empty">
        <p>No recipe found for the selected element.</p>
      </div>
    )
  }

  return (
    <div className="tree-container" ref={containerRef}>
      <svg ref={svgRef}></svg>

      <div className="zoom-controls">
        <button className="zoom-button" onClick={handleZoomIn}>
          +
        </button>
        <button className="zoom-button" onClick={handleResetZoom}>
          ⟳
        </button>
        <button className="zoom-button" onClick={handleZoomOut}>
          -
        </button>
      </div>
    </div>
  )
}

helpers.js


// Mock data for elements
const MOCK_ELEMENTS = [ 
    { id: 1, name: "Water", category: "Basic" },
    { id: 2, name: "Fire", category: "Basic" },
    { id: 3, name: "Earth", category: "Basic" },
    { id: 4, name: "Air", category: "Basic" },
    { id: 5, name: "Heat", category: "Derived" },
    { id: 6, name: "Ice", category: "Derived" },
    { id: 7, name: "Snow", category: "Derived" },
    { id: 8, name: "Coal", category: "Derived" },
    { id: 9, name: "Mud", category: "Derived" },
    { id: 10, name: "Stone", category: "Derived" },
    { id: 11, name: "Clay", category: "Derived" },
    { id: 12, name: "Brick", category: "Derived" },
    { id: 13, name: "Sand", category: "Derived" },
    { id: 14, name: "Glass", category: "Derived" },
    { id: 15, name: "Metal", category: "Derived" },
    { id: 16, name: "Steam", category: "Derived" },
  ]
  
  /**
   * Fetch all elements from the API or use mock data
   * @returns {Promise<Array>} Array of elements
   */
  export const fetchElements = async () => {
    try {
      // Try to fetch from API first
      const response = await fetch("/api/elements")
      if (response.ok) {
        return await response.json()
      }
    } catch (error) {
      console.warn("Failed to fetch elements from API, using mock data", error)
    }
  
    // Return mock data if API fails
    return MOCK_ELEMENTS
  }
  
  /**
   * Format time in milliseconds to a readable format
   * @param {number} ms - Time in milliseconds
   * @returns {string} Formatted time
   */
  export const formatTime = (ms) => {
    if (ms < 1000) {
      return `${ms}ms`
    }
  
    const seconds = Math.floor(ms / 1000)
    const remainingMs = ms % 1000
  
    if (seconds < 60) {
      return `${seconds}.${remainingMs.toString().padStart(3, "0")}s`
    }
  
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
  
    return `${minutes}m ${remainingSeconds}s`
  }
  
  /**
   * Format large numbers with commas
   * @param {number} num - Number to format
   * @returns {string} Formatted number
   */
  export const formatNumber = (num) => {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
  }
  
useSearch,js

"use client"

import { useState, useEffect } from "react"

export function useSearch(initialItems = []) {
  const [searchParams, setSearchParams] = useState({
    algorithm: "BFS",
    recipeType: "Best",
    maxRecipes: 5,
  })

  // Search results and metrics for recipe search
  const [searchResults, setSearchResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)
  const [executionTime, setExecutionTime] = useState(0)
  const [nodesVisited, setNodesVisited] = useState(0)
  const [progress, setProgress] = useState(0)

  // element filtering functionality
  const [searchTerm, setSearchTerm] = useState("")
  const [items, setItems] = useState(initialItems)
  const [filteredItems, setFilteredItems] = useState(initialItems)

  // Update items when initialItems changes
  useEffect(() => {
    setItems(initialItems)
    setFilteredItems(initialItems) // Show all items by default
  }, [initialItems])

  // Filter items whenever searchTerm change
  useEffect(() => {
    if (!searchTerm.trim()) {
      // When search is empty, show all items
      setFilteredItems(items)
      return
    }

    const searchTermLower = searchTerm.toLowerCase()
    
    console.log("Search term:", searchTermLower)
    console.log("Available items:", items)
    
    const filtered = items.filter(item => {
      // Handle null 
      if (!item) return false
      
      // Check if item has a name property
      if (typeof item === 'object') {
        const itemName = item.name ? String(item.name) : '';
        
        const nameMatch = itemName.toLowerCase().includes(searchTermLower)
        
        console.log(`Item "${itemName}", matches: ${nameMatch}`)
        
        const itemDesc = item.description ? String(item.description) : '';
        
        // Check if description contains search term 
        const descriptionMatch = itemDesc.toLowerCase().includes(searchTermLower)
        
        return nameMatch || descriptionMatch
      } else if (typeof item === 'string') {
        return item.toLowerCase().includes(searchTermLower)
      }
      
      return false
    })

    console.log("Filtered items:", filtered)
    setFilteredItems(filtered)
  }, [searchTerm, items])

  const startSearch = async (element) => {
    setIsLoading(true)
    setSearchResults([])
    setExecutionTime(0)
    setNodesVisited(0)
    setProgress(0)

    try {
      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setProgress((prev) => {
          if (prev >= 95) {
            clearInterval(progressInterval)
            return 95
          }
          return prev + 5
        })
      }, 200)

      // Simulate API call to backend
      const startTime = performance.now()

      const response = await fetch(`/api/search`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          elementId: element.id,
          algorithm: searchParams.algorithm,
          recipeType: searchParams.recipeType,
          maxRecipes: searchParams.maxRecipes,
        }),
      })

      const data = await response.json()
      const endTime = performance.now()

      clearInterval(progressInterval)
      setProgress(100)

      // Set results
      setSearchResults(data.results || [])
      setExecutionTime(Math.round(endTime - startTime))
      setNodesVisited(data.nodesVisited || 0)

      // Simulate delay 
      setTimeout(() => {
        setIsLoading(false)
      }, 500)
    } catch (error) {
      console.error("Search error:", error)
      setIsLoading(false)
      setProgress(0)
    }
  }

  const resetSearch = () => {
    setSearchResults([])
    setExecutionTime(0)
    setNodesVisited(0)
    setProgress(0)
  }

  return {
    searchParams,
    setSearchParams,
    searchResults,
    isLoading,
    executionTime,
    nodesVisited,
    progress,
    startSearch,
    resetSearch,
    
    searchTerm,
    setSearchTerm,
    items,
    setItems,
    filteredItems,
    hasResults: filteredItems.length > 0,
    isSearching: searchTerm.trim() !== ""
  }
}

coba juga berikan command setiap perubahan dan penyesuaian supaya saya paham 
